import sys
import anndata as ad
import cellmapper as cm
from scipy.sparse import csc_matrix

## VIASH START
# Note: this section is auto-generated by viash at runtime. To edit it, make changes
# in config.vsh.yaml and then run `viash config inject config.vsh.yaml`.
par = {
    'input_train_mod1': 'resources_test/task_predict_modality/openproblems_neurips2021/bmmc_multiome/swap/train_mod1.h5ad',
    'input_train_mod2': 'resources_test/task_predict_modality/openproblems_neurips2021/bmmc_multiome/swap/train_mod2.h5ad',
    'input_test_mod1': 'resources_test/task_predict_modality/openproblems_neurips2021/bmmc_multiome/swap/test_mod1.h5ad',
    'output': 'output.h5ad',
    'n_neighbors': 50,
    'kernel_method': 'gauss',
    'use_hvg': False,
    'adt_normalization': 'clr',  # Normalization method for ADT data
    'plot_umap': True,

}
meta = {
  'name': 'cellmapper_scvi',
  'resources_dir': 'target/executable/methods/cellmapper_scvi',
}
## VIASH END

sys.path.append(meta['resources_dir'])
from utils import get_representation

print('Reading input files', flush=True)
input_train_mod1 = ad.read_h5ad(par['input_train_mod1'])
input_train_mod2 = ad.read_h5ad(par['input_train_mod2'])
input_test_mod1 = ad.read_h5ad(par['input_test_mod1'])

mod1 = input_train_mod1.uns['modality']
mod2 = input_train_mod2.uns['modality']
print(f"Modality 1: {mod1}, n_features: {input_train_mod1.n_vars}", flush=True)
print(f"Modality 2: {mod2}, n_features: {input_train_mod2.n_vars}", flush=True)

print("Concatenating train and test data", flush=True)
adata = ad.concat(
    [input_train_mod1, input_test_mod1], merge = "same", label="split", keys=["train", "test"]
    )
adata.X = adata.layers["counts"]

# Compute a latent representation using an appropriate model based on the modality
print("Get latent representation", flush=True)
adata = get_representation(
    adata=adata, modality=mod1, use_hvg=par['use_hvg'], adt_normalization=par['adt_normalization'], plot_umap=par['plot_umap']
    )

# Place the representation back into individual objects
input_train_mod1.obsm["X_scvi"] = adata[adata.obs["split"] == "train"].obsm["X_scvi"].copy()
input_test_mod1.obsm["X_scvi"] = adata[adata.obs["split"] == "test"].obsm["X_scvi"].copy()

# copy the normalized layer to obsm for mod2
input_train_mod1.obsm["mod2"] = input_train_mod2.layers["normalized"] 

# choose the kNN method based on total cell number
n_obs = input_test_mod1.n_obs + input_train_mod1.n_obs

print('Setup and prepare Cellmapper', flush=True)
cmap = cm.CellMapper(query=input_test_mod1, reference=input_train_mod1)
cmap.compute_neighbors(
    use_rep="X_scvi",
    knn_method="sklearn" if n_obs < 60000 else "pynndescent",
    n_neighbors=par['n_neighbors'], 
    )
cmap.compute_mapping_matrix(kernel_method=par['kernel_method'])

print("Predict on test data", flush=True)
cmap.map_obsm(key="mod2", prediction_postfix="pred")
mod2_pred = csc_matrix(cmap.query.obsm["mod2_pred"])

print("Write output AnnData to file", flush=True)
output = ad.AnnData(
    layers={"normalized": mod2_pred},
    obs=input_test_mod1.obs,
    var=input_train_mod2.var,
    uns={
        'dataset_id': input_train_mod1.uns['dataset_id'],
        'method_id': meta["name"],
    },
)
output.write_h5ad(par['output'], compression='gzip')
